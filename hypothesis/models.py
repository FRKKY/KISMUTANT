"""
HYPOTHESIS - Trading Strategy Definitions and Lifecycle

A Hypothesis is a testable trading idea that can be:
1. Generated from detected patterns
2. Backtested on historical data
3. Paper traded for validation
4. Promoted to live trading
5. Retired when performance degrades

Lifecycle: INCUBATING → PAPER_TRADING → LIVE → RETIRED
"""

from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Optional, List, Dict, Any, Callable
from enum import Enum
from decimal import Decimal
import uuid
import json

from loguru import logger


class StrategyState(str, Enum):
    """Lifecycle states for a trading strategy."""
    
    INCUBATING = "incubating"       # Being backtested
    PAPER_TRADING = "paper_trading"  # Live paper trading validation
    LIVE = "live"                    # Real money trading
    PAUSED = "paused"               # Temporarily halted
    RETIRED = "retired"             # No longer active


class SignalType(str, Enum):
    """Types of trading signals."""
    
    LONG_ENTRY = "long_entry"
    LONG_EXIT = "long_exit"
    SHORT_ENTRY = "short_entry"
    SHORT_EXIT = "short_exit"
    SCALE_IN = "scale_in"
    SCALE_OUT = "scale_out"
    STOP_LOSS = "stop_loss"
    TAKE_PROFIT = "take_profit"


class StrategyType(str, Enum):
    """Categories of trading strategies."""
    
    MOMENTUM = "momentum"
    MEAN_REVERSION = "mean_reversion"
    BREAKOUT = "breakout"
    TREND_FOLLOWING = "trend_following"
    STATISTICAL_ARBITRAGE = "stat_arb"
    VOLATILITY = "volatility"
    MULTI_FACTOR = "multi_factor"


@dataclass
class TradingSignal:
    """A trading signal generated by a strategy."""
    
    signal_id: str
    hypothesis_id: str
    symbol: str
    timestamp: datetime
    
    signal_type: SignalType
    direction: int  # 1 for long, -1 for short, 0 for exit
    
    # Price levels
    price: float
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    
    # Sizing
    size_pct: Optional[float] = None  # Percentage of allocated capital
    size_shares: Optional[int] = None
    
    # Confidence and metadata
    confidence: float = 0.5
    reason: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "signal_id": self.signal_id,
            "hypothesis_id": self.hypothesis_id,
            "symbol": self.symbol,
            "timestamp": self.timestamp.isoformat(),
            "signal_type": self.signal_type.value,
            "direction": self.direction,
            "price": self.price,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "confidence": self.confidence,
            "reason": self.reason
        }


@dataclass
class PerformanceMetrics:
    """Performance metrics for a strategy."""
    
    # Returns
    total_return: float = 0.0
    annualized_return: float = 0.0
    
    # Risk metrics
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    max_drawdown: float = 0.0
    volatility: float = 0.0
    
    # Trade statistics
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    win_rate: float = 0.0
    avg_win: float = 0.0
    avg_loss: float = 0.0
    profit_factor: float = 0.0
    
    # Time metrics
    avg_holding_period_hours: float = 0.0
    max_consecutive_wins: int = 0
    max_consecutive_losses: int = 0
    
    # Statistical significance
    t_statistic: Optional[float] = None
    p_value: Optional[float] = None
    
    # Period
    start_date: Optional[datetime] = None
    end_date: Optional[datetime] = None
    trading_days: int = 0
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "total_return": self.total_return,
            "annualized_return": self.annualized_return,
            "sharpe_ratio": self.sharpe_ratio,
            "sortino_ratio": self.sortino_ratio,
            "max_drawdown": self.max_drawdown,
            "volatility": self.volatility,
            "total_trades": self.total_trades,
            "win_rate": self.win_rate,
            "profit_factor": self.profit_factor,
            "t_statistic": self.t_statistic,
            "p_value": self.p_value,
            "trading_days": self.trading_days
        }
    
    def passes_promotion_criteria(
        self,
        min_sharpe: float = 1.0,
        max_drawdown: float = 0.15,
        min_trades: int = 30,
        min_win_rate: float = 0.4,
        min_profit_factor: float = 1.5
    ) -> tuple[bool, List[str]]:
        """
        Check if metrics pass promotion criteria.
        
        Returns:
            Tuple of (passes, list of failed criteria)
        """
        failures = []
        
        if self.sharpe_ratio < min_sharpe:
            failures.append(f"Sharpe {self.sharpe_ratio:.2f} < {min_sharpe}")
        
        if self.max_drawdown > max_drawdown:
            failures.append(f"Max DD {self.max_drawdown:.1%} > {max_drawdown:.1%}")
        
        if self.total_trades < min_trades:
            failures.append(f"Trades {self.total_trades} < {min_trades}")
        
        if self.win_rate < min_win_rate:
            failures.append(f"Win rate {self.win_rate:.1%} < {min_win_rate:.1%}")
        
        if self.profit_factor < min_profit_factor:
            failures.append(f"Profit factor {self.profit_factor:.2f} < {min_profit_factor}")
        
        return len(failures) == 0, failures


@dataclass
class Hypothesis:
    """
    A trading hypothesis/strategy that can be tested and deployed.
    
    This is the core unit of the system's adaptive trading capability.
    """
    
    # Identity
    hypothesis_id: str
    name: str
    description: str
    strategy_type: StrategyType
    
    # State
    state: StrategyState = StrategyState.INCUBATING
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    
    # Source
    source_pattern_id: Optional[str] = None  # Pattern that generated this
    source_research: Optional[str] = None    # Research paper reference
    
    # Universe
    symbols: List[str] = field(default_factory=list)  # Symbols this trades
    
    # Parameters (strategy-specific)
    parameters: Dict[str, Any] = field(default_factory=dict)
    
    # Entry/Exit rules (as serializable config)
    entry_rules: Dict[str, Any] = field(default_factory=dict)
    exit_rules: Dict[str, Any] = field(default_factory=dict)
    
    # Risk management
    max_position_pct: float = 0.1        # Max 10% of capital per position
    stop_loss_pct: float = 0.02          # 2% stop loss
    take_profit_pct: Optional[float] = None
    max_holding_days: Optional[int] = None
    
    # Performance tracking
    backtest_metrics: Optional[PerformanceMetrics] = None
    paper_metrics: Optional[PerformanceMetrics] = None
    live_metrics: Optional[PerformanceMetrics] = None
    
    # Capital allocation
    allocated_capital: float = 0.0       # Current allocated capital
    capital_pct: float = 0.0             # Percentage of total capital
    
    # Lifecycle timestamps
    incubation_start: Optional[datetime] = None
    paper_start: Optional[datetime] = None
    live_start: Optional[datetime] = None
    retired_at: Optional[datetime] = None
    
    # Metadata
    version: int = 1
    parent_id: Optional[str] = None      # If evolved from another hypothesis
    tags: List[str] = field(default_factory=list)
    notes: str = ""
    
    def __post_init__(self):
        if not self.hypothesis_id:
            self.hypothesis_id = f"hyp_{uuid.uuid4().hex[:12]}"
        if not self.incubation_start:
            self.incubation_start = datetime.now()
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "hypothesis_id": self.hypothesis_id,
            "name": self.name,
            "description": self.description,
            "strategy_type": self.strategy_type.value,
            "state": self.state.value,
            "created_at": self.created_at.isoformat(),
            "symbols": self.symbols,
            "parameters": self.parameters,
            "max_position_pct": self.max_position_pct,
            "stop_loss_pct": self.stop_loss_pct,
            "allocated_capital": self.allocated_capital,
            "backtest_metrics": self.backtest_metrics.to_dict() if self.backtest_metrics else None,
            "paper_metrics": self.paper_metrics.to_dict() if self.paper_metrics else None,
            "live_metrics": self.live_metrics.to_dict() if self.live_metrics else None,
            "tags": self.tags
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Hypothesis':
        """Create Hypothesis from dictionary."""
        # Handle enum conversions
        data['strategy_type'] = StrategyType(data['strategy_type'])
        data['state'] = StrategyState(data['state'])
        
        # Handle datetime conversions
        for dt_field in ['created_at', 'updated_at', 'incubation_start', 
                         'paper_start', 'live_start', 'retired_at']:
            if data.get(dt_field) and isinstance(data[dt_field], str):
                data[dt_field] = datetime.fromisoformat(data[dt_field])
        
        return cls(**data)
    
    def get_current_metrics(self) -> Optional[PerformanceMetrics]:
        """Get metrics for current state."""
        if self.state == StrategyState.LIVE:
            return self.live_metrics
        elif self.state == StrategyState.PAPER_TRADING:
            return self.paper_metrics
        else:
            return self.backtest_metrics
    
    def can_promote(self) -> tuple[bool, List[str]]:
        """Check if hypothesis can be promoted to next state."""
        if self.state == StrategyState.INCUBATING:
            if not self.backtest_metrics:
                return False, ["No backtest metrics"]
            return self.backtest_metrics.passes_promotion_criteria(
                min_sharpe=1.0,
                max_drawdown=0.15,
                min_trades=30
            )
        
        elif self.state == StrategyState.PAPER_TRADING:
            if not self.paper_metrics:
                return False, ["No paper trading metrics"]
            
            # Check minimum paper trading duration (30 days)
            if self.paper_start:
                days_in_paper = (datetime.now() - self.paper_start).days
                if days_in_paper < 30:
                    return False, [f"Only {days_in_paper} days in paper (need 30)"]
            
            return self.paper_metrics.passes_promotion_criteria(
                min_sharpe=0.75,  # Lower bar for paper
                max_drawdown=0.10,
                min_trades=20
            )
        
        return False, ["Cannot promote from current state"]
    
    def should_demote(self) -> tuple[bool, List[str]]:
        """Check if hypothesis should be demoted."""
        metrics = self.get_current_metrics()
        if not metrics:
            return False, []
        
        reasons = []
        
        # Rolling 30-day Sharpe below 0.5
        if metrics.sharpe_ratio < 0.5:
            reasons.append(f"Sharpe ratio {metrics.sharpe_ratio:.2f} < 0.5")
        
        # Drawdown exceeds 10%
        if metrics.max_drawdown > 0.10:
            reasons.append(f"Drawdown {metrics.max_drawdown:.1%} > 10%")
        
        # 5+ consecutive losses
        if metrics.max_consecutive_losses >= 5:
            reasons.append(f"{metrics.max_consecutive_losses} consecutive losses")
        
        return len(reasons) > 0, reasons


@dataclass
class PromotionCriteria:
    """Criteria for promoting strategies between states."""
    
    # Incubating → Paper Trading
    backtest_min_sharpe: float = 1.0
    backtest_max_drawdown: float = 0.15
    backtest_min_trades: int = 30
    backtest_min_profit_factor: float = 1.5
    
    # Paper Trading → Live
    paper_min_days: int = 30
    paper_min_sharpe: float = 0.75
    paper_max_drawdown: float = 0.10
    paper_min_trades: int = 20
    paper_min_profit_factor: float = 1.3


@dataclass 
class DemotionCriteria:
    """Criteria for demoting or retiring strategies."""
    
    # Rolling performance thresholds
    rolling_window_days: int = 30
    min_sharpe: float = 0.5
    max_drawdown: float = 0.10
    max_consecutive_losses: int = 5
    
    # Retirement triggers
    days_underperforming: int = 14  # Consecutive days below thresholds
    min_trades_for_evaluation: int = 10


class HypothesisFactory:
    """Factory for creating hypotheses from patterns and templates."""
    
    @staticmethod
    def from_pattern(
        pattern,  # DetectedPattern
        symbols: Optional[List[str]] = None
    ) -> Hypothesis:
        """
        Create a hypothesis from a detected pattern.
        
        Maps pattern types to strategy types and creates
        appropriate entry/exit rules.
        """
        from perception.patterns import PatternType, PatternDirection
        
        # Map pattern types to strategy types
        pattern_to_strategy = {
            PatternType.BREAKOUT_RESISTANCE: StrategyType.BREAKOUT,
            PatternType.BREAKOUT_SUPPORT: StrategyType.BREAKOUT,
            PatternType.BOLLINGER_BREAKOUT: StrategyType.BREAKOUT,
            PatternType.MEAN_REVERSION_OVERSOLD: StrategyType.MEAN_REVERSION,
            PatternType.MEAN_REVERSION_OVERBOUGHT: StrategyType.MEAN_REVERSION,
            PatternType.MOMENTUM_SURGE: StrategyType.MOMENTUM,
            PatternType.TREND_CONTINUATION: StrategyType.TREND_FOLLOWING,
            PatternType.GOLDEN_CROSS: StrategyType.TREND_FOLLOWING,
            PatternType.DEATH_CROSS: StrategyType.TREND_FOLLOWING,
        }
        
        strategy_type = pattern_to_strategy.get(
            pattern.pattern_type, 
            StrategyType.MULTI_FACTOR
        )
        
        # Determine direction
        is_long = pattern.direction == PatternDirection.BULLISH
        
        # Build entry rules based on pattern type
        entry_rules = {
            "pattern_type": pattern.pattern_type.value,
            "direction": "long" if is_long else "short",
            "min_confidence": pattern.confidence * 0.9,  # Slightly lower threshold
        }
        
        # Add pattern-specific conditions
        if pattern.pattern_type in [PatternType.BREAKOUT_RESISTANCE, PatternType.BREAKOUT_SUPPORT]:
            entry_rules["breakout_confirmation_bars"] = 2
            entry_rules["volume_confirmation"] = True
        
        elif pattern.pattern_type in [PatternType.MEAN_REVERSION_OVERSOLD, PatternType.MEAN_REVERSION_OVERBOUGHT]:
            entry_rules["rsi_threshold"] = 30 if is_long else 70
            entry_rules["wait_for_reversal"] = True
        
        # Build exit rules
        exit_rules = {
            "stop_loss_atr_multiple": 2.0,
            "take_profit_atr_multiple": 3.0,
            "max_holding_days": 10,
            "trailing_stop": True,
            "trailing_stop_atr": 1.5
        }
        
        # Calculate stop loss and take profit from pattern
        if pattern.stop_loss and pattern.entry_price:
            stop_pct = abs(pattern.entry_price - pattern.stop_loss) / pattern.entry_price
        else:
            stop_pct = 0.02
        
        hypothesis = Hypothesis(
            hypothesis_id=f"hyp_{pattern.pattern_id}",
            name=f"{pattern.pattern_type.value}_{pattern.symbol}",
            description=f"Auto-generated from {pattern.pattern_type.value} pattern on {pattern.symbol}",
            strategy_type=strategy_type,
            source_pattern_id=pattern.pattern_id,
            symbols=symbols or [pattern.symbol],
            parameters={
                "source_confidence": pattern.confidence,
                "source_timestamp": pattern.timestamp.isoformat(),
            },
            entry_rules=entry_rules,
            exit_rules=exit_rules,
            stop_loss_pct=stop_pct,
            tags=[pattern.pattern_type.value, pattern.direction.value]
        )
        
        return hypothesis
    
    @staticmethod
    def momentum_strategy(
        symbols: List[str],
        lookback_period: int = 20,
        threshold: float = 0.02
    ) -> Hypothesis:
        """Create a momentum strategy hypothesis."""
        return Hypothesis(
            hypothesis_id="",
            name=f"Momentum_{lookback_period}d",
            description=f"Buy when {lookback_period}-day return exceeds {threshold:.1%}",
            strategy_type=StrategyType.MOMENTUM,
            symbols=symbols,
            parameters={
                "lookback_period": lookback_period,
                "entry_threshold": threshold,
                "exit_threshold": -threshold / 2
            },
            entry_rules={
                "condition": f"roc_{lookback_period} > {threshold * 100}",
                "volume_filter": "volume_ratio_20 > 1.0"
            },
            exit_rules={
                "stop_loss_pct": 0.02,
                "take_profit_pct": 0.05,
                "trailing_stop": True
            },
            tags=["momentum", "systematic"]
        )
    
    @staticmethod
    def mean_reversion_strategy(
        symbols: List[str],
        zscore_entry: float = 2.0,
        zscore_exit: float = 0.5
    ) -> Hypothesis:
        """Create a mean reversion strategy hypothesis."""
        return Hypothesis(
            hypothesis_id="",
            name=f"MeanRev_Z{zscore_entry}",
            description=f"Enter when Z-score exceeds {zscore_entry}, exit at {zscore_exit}",
            strategy_type=StrategyType.MEAN_REVERSION,
            symbols=symbols,
            parameters={
                "zscore_entry": zscore_entry,
                "zscore_exit": zscore_exit,
                "lookback_period": 50
            },
            entry_rules={
                "long_condition": f"price_zscore < -{zscore_entry}",
                "short_condition": f"price_zscore > {zscore_entry}",
                "rsi_filter": True
            },
            exit_rules={
                "exit_condition": f"abs(price_zscore) < {zscore_exit}",
                "max_holding_days": 5,
                "stop_loss_zscore": 3.0
            },
            tags=["mean_reversion", "systematic"]
        )
    
    @staticmethod
    def ma_crossover_strategy(
        symbols: List[str],
        fast_period: int = 10,
        slow_period: int = 30
    ) -> Hypothesis:
        """Create a moving average crossover strategy."""
        return Hypothesis(
            hypothesis_id="",
            name=f"MACross_{fast_period}_{slow_period}",
            description=f"Trade {fast_period}/{slow_period} EMA crossovers",
            strategy_type=StrategyType.TREND_FOLLOWING,
            symbols=symbols,
            parameters={
                "fast_period": fast_period,
                "slow_period": slow_period,
                "use_ema": True
            },
            entry_rules={
                "long": f"ema_{fast_period} crosses above ema_{slow_period}",
                "short": f"ema_{fast_period} crosses below ema_{slow_period}",
                "adx_filter": "adx > 20"
            },
            exit_rules={
                "exit_on_reverse_cross": True,
                "stop_loss_atr": 2.0,
                "trailing_stop": True
            },
            tags=["trend", "crossover", "systematic"]
        )

    @staticmethod
    def from_research(research_hypothesis) -> "Hypothesis":
        """
        Convert a ResearchHypothesis to a Hypothesis for registry.

        Args:
            research_hypothesis: ResearchHypothesis object from research module

        Returns:
            Hypothesis object suitable for strategy registry
        """
        # Map string strategy type to enum
        strategy_type_map = {
            "momentum": StrategyType.MOMENTUM,
            "mean_reversion": StrategyType.MEAN_REVERSION,
            "breakout": StrategyType.BREAKOUT,
            "trend_following": StrategyType.TREND_FOLLOWING,
            "stat_arb": StrategyType.STATISTICAL_ARBITRAGE,
            "volatility": StrategyType.VOLATILITY,
            "multi_factor": StrategyType.MULTI_FACTOR,
        }

        strategy_type = strategy_type_map.get(
            research_hypothesis.strategy_type,
            StrategyType.MULTI_FACTOR
        )

        # Extract parameters with defaults
        params = research_hypothesis.parameters.copy() if research_hypothesis.parameters else {}
        stop_loss = params.get("stop_loss_pct", 0.05)
        take_profit = params.get("take_profit_pct", 0.15)

        # Build entry rules from logic string
        entry_rules = {
            "logic": research_hypothesis.entry_logic,
            "source": "research",
        }

        # Build exit rules from logic string
        exit_rules = {
            "logic": research_hypothesis.exit_logic,
            "stop_loss_pct": stop_loss,
            "take_profit_pct": take_profit,
        }

        return Hypothesis(
            hypothesis_id=research_hypothesis.hypothesis_id,
            name=research_hypothesis.name,
            description=research_hypothesis.description,
            strategy_type=strategy_type,
            source_research=research_hypothesis.source_paper_id,
            symbols=[],  # Research hypotheses apply broadly, symbols assigned later
            parameters=params,
            entry_rules=entry_rules,
            exit_rules=exit_rules,
            stop_loss_pct=stop_loss,
            take_profit_pct=take_profit,
            tags=["research", research_hypothesis.strategy_type]
        )
